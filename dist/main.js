/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Camera.ts":
/*!***********************!*\
  !*** ./src/Camera.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transform */ \"./src/Transform.ts\");\n\nvar Camera = /** @class */ (function () {\n    function Camera() {\n        //Camera transform\n        this.transform = new _Transform__WEBPACK_IMPORTED_MODULE_0__.Transform;\n        this.CameraToProjection = new Float32Array([\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1,\n        ]);\n    }\n    /**\n     * Computes a CamerToProJectionMatrix\n     * @param fov Field of view in degrees\n     * @param aspectRatio The proportion of width and height\n     * @param near The near clipping plane\n     * @param far The far clipping plane\n     *\n     * @source https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#simple_projection\n     */\n    Camera.prototype.setCameraToProjectionMatrix = function (fov, aspectRatio, near, far) {\n        var fovRad = fov * Math.PI / 180;\n        var f = 1.0 / Math.tan(Math.PI * .5 - .5 * fovRad);\n        var rangInv = 1.0 / (near - far);\n        this.CameraToProjection[0] = f / aspectRatio;\n        this.CameraToProjection[5] = f;\n        this.CameraToProjection[10] = (near + far) * rangInv;\n        this.CameraToProjection[11] = -1;\n        this.CameraToProjection[14] = near * far * rangInv * 2;\n    };\n    Camera.prototype.getCameraToProjectionMatrix = function () { return this.CameraToProjection; };\n    Camera.prototype.getWorldToCameraMatrix = function () {\n        var rotations = this.transform.getRotation();\n        var translations = this.transform.getTranslation();\n        var tempTransform = new _Transform__WEBPACK_IMPORTED_MODULE_0__.Transform();\n        //Invert the cameras transform.\n        tempTransform.setRotation(-rotations[0], -rotations[1], -rotations[2]);\n        tempTransform.setTranslation(-translations[0], -translations[1], -translations[2]);\n        return tempTransform.computeTransformMatrix();\n    };\n    return Camera;\n}());\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/Camera.ts?");

/***/ }),

/***/ "./src/GLWrapper.ts":
/*!**************************!*\
  !*** ./src/GLWrapper.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GL_Wrapper: () => (/* binding */ GL_Wrapper)\n/* harmony export */ });\n/* harmony import */ var _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderProgramHelper */ \"./src/ShaderProgramHelper.ts\");\n\nvar GL_Wrapper = /** @class */ (function () {\n    function GL_Wrapper(canvas) {\n        this.canvas = canvas;\n        this.context = canvas.getContext('webgl2');\n        this.shaderProgramHelper = null;\n        this.context.enable(this.context.DEPTH_TEST);\n    }\n    /**\n     * makeSeededProgramWrapper\n     * Returns a program wrapper seeded with the context for this GL_Wrapper, but with no shader data. A user should load their shader\n     * code into the the program wrapper and then set then attach it too this class with attachProgramWrapper.\n     * @returns {ShaderProgramHelper} - A program wrapper seeded with the context for this GL_Wrapper, but with no shader data.\n     */\n    GL_Wrapper.prototype.makeSeededProgramWrapper = function () {\n        return new _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramHelper(this.context);\n    };\n    /**\n     * attachProgramWrapper\n     * sets a program wrapper to be actually used by this GLWrapper\n     * @param {ShaderProgramHelper} programWrapper - A program wrapper seeded with the context for this GL_Wrapper and with shader data..\n     */\n    GL_Wrapper.prototype.attachProgramWrapper = function (programWrapper) {\n        this.shaderProgramHelper = programWrapper;\n        this.shaderProgramHelper.useProgram();\n    };\n    /**\n     * buildAndPushArrayBuffer\n     * Creates an Array Buffer and pushes it to the GPU\n     * @param {BufferSource} data - The actual data to buffer over.\n     * @returns {WebGLBuffer}\n     */\n    GL_Wrapper.prototype.buildAndPushArrayBuffer = function (data) {\n        var buffer = this.context.createBuffer();\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, buffer);\n        this.context.bufferData(this.context.ARRAY_BUFFER, data, this.context.STATIC_DRAW);\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, null);\n        return buffer;\n    };\n    /**\n     * buildAndPushElementArrayBuffer\n     * Creates an Element Array Buffer and pushes it to the GPU\n     * @param {BufferSource} data - The actual data to buffer over.\n     * @returns {WebGLBuffer}\n     */\n    GL_Wrapper.prototype.buildAndPushElementArrayBuffer = function (data) {\n        var buffer = this.context.createBuffer();\n        this.context.bindBuffer(this.context.ELEMENT_ARRAY_BUFFER, buffer);\n        this.context.bufferData(this.context.ELEMENT_ARRAY_BUFFER, data, this.context.STATIC_DRAW);\n        this.context.bindBuffer(this.context.ELEMENT_ARRAY_BUFFER, null);\n        return buffer;\n    };\n    /**\n     * bindAttributeNameToBuffer\n     * This binds a buffer to an attribute. It also loads this information about how to read the buffer into the attribute.\n     * @param {WebGLBuffer} buffer - Reference to the buffer containing the attribute data.\n     * @param {string} attributeName - The string name of the attribute you are binding\n     * @param {number} amntPerVertex - The amount of values in this buffer to read for one instance of the attribute. floats or vectors?????\n     * @param {boolean} normalize - Does the data need to be normalized.\n     * @param {number} stride - The stride to jump per attribute??? is that not number??\n     * @param {number} offset - The offset to jump from the beginning of the buffer\n     */\n    GL_Wrapper.prototype.bindAttributeNameToBuffer = function (buffer, attributeName, amntPerVertex, normalize, stride, offset) {\n        if (this.shaderProgramHelper == null) {\n            throw \"No shader program to try and attach attribute \".concat(attributeName, \" to!\");\n        }\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, buffer);\n        var loc = this.shaderProgramHelper.getAttributeLocation(attributeName);\n        this.context.vertexAttribPointer(loc, amntPerVertex, this.context.FLOAT, normalize, stride, offset);\n        this.context.enableVertexAttribArray(loc);\n        this.context.bindBuffer(this.context.ARRAY_BUFFER, null);\n    };\n    /**\n     * This function binds a matrix to a uniform in the program.\n     * @param matrix The matrix in column major order.\n     * @param size The size of the matrix 1x1 -> 1, 4x4 -> 4.\n     * @param uniformName The name of the uniform to bind this to.\n     */\n    GL_Wrapper.prototype.bindMatrixUniform = function (matrix, size, uniformName) {\n        if (this.shaderProgramHelper == null) {\n            throw \"No shader program to try and attach uniform \".concat(uniformName, \" to!\");\n        }\n        var loc = this.shaderProgramHelper.getUniformLocation(uniformName);\n        switch (size) {\n            case 2: {\n                this.context.uniformMatrix2fv(loc, false, matrix);\n                break;\n            }\n            case 3: {\n                this.context.uniformMatrix3fv(loc, false, matrix);\n                break;\n            }\n            case 4: {\n                this.context.uniformMatrix4fv(loc, false, matrix);\n                break;\n            }\n            default: {\n                throw \"Matrix size of \".concat(size, \" has no gl sibling!\");\n            }\n        }\n    };\n    /**\n     * This function binds a vector to a uniform in the program.\n     * @param vector The vector\n     * @param uniformName The name of the uniform to bind this to.\n     */\n    GL_Wrapper.prototype.bindVectorUniform = function (vector, uniformName) {\n        if (this.shaderProgramHelper == null) {\n            throw \"No shader program to try and attach uniform \".concat(uniformName, \" to!\");\n        }\n        var loc = this.shaderProgramHelper.getUniformLocation(uniformName);\n        this.context.uniform4f(loc, vector[0], vector[1], vector[2], vector[3]);\n    };\n    GL_Wrapper.prototype.draw = function (indexBuffer, indexLength, mode) {\n        this.context.bindBuffer(this.context.ELEMENT_ARRAY_BUFFER, indexBuffer);\n        this.context.clearColor(0.114, 0.541, 0.522, 1.0);\n        this.context.viewport(0, 0, this.canvas.width, this.canvas.height);\n        var drawMode;\n        switch (mode) {\n            case GL_Wrapper.drawModes.LINES: {\n                drawMode = this.context.LINE_LOOP;\n                break;\n            }\n            case GL_Wrapper.drawModes.TRIANGLES: {\n                drawMode = this.context.TRIANGLES;\n                break;\n            }\n            case GL_Wrapper.drawModes.TRIANGLE_STRIP: {\n                drawMode = this.context.TRIANGLE_STRIP;\n                break;\n            }\n            case GL_Wrapper.drawModes.POINTS: {\n                drawMode = this.context.POINTS;\n                break;\n            }\n        }\n        this.context.drawElements(drawMode, indexLength, this.context.UNSIGNED_SHORT, 0);\n    };\n    GL_Wrapper.prototype.clear = function () {\n        this.context.clear(this.context.COLOR_BUFFER_BIT);\n    };\n    GL_Wrapper.prototype.reportError = function () {\n        var err = this.context.getError();\n        if (err > 0) {\n            console.error(\"GL ERROR! Code: \".concat(err));\n        }\n    };\n    GL_Wrapper.prototype.deleteBuffer = function (buffer) {\n        this.context.deleteBuffer(buffer);\n    };\n    return GL_Wrapper;\n}());\n\n(function (GL_Wrapper) {\n    var drawModes;\n    (function (drawModes) {\n        drawModes[drawModes[\"LINES\"] = 0] = \"LINES\";\n        drawModes[drawModes[\"TRIANGLES\"] = 1] = \"TRIANGLES\";\n        drawModes[drawModes[\"TRIANGLE_STRIP\"] = 2] = \"TRIANGLE_STRIP\";\n        drawModes[drawModes[\"POINTS\"] = 3] = \"POINTS\";\n    })(drawModes = GL_Wrapper.drawModes || (GL_Wrapper.drawModes = {}));\n})(GL_Wrapper || (GL_Wrapper = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/GLWrapper.ts?");

/***/ }),

/***/ "./src/Geometry.ts":
/*!*************************!*\
  !*** ./src/Geometry.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Geometry: () => (/* binding */ Geometry)\n/* harmony export */ });\nvar Geometry = /** @class */ (function () {\n    function Geometry() {\n    }\n    Geometry.prototype.setVertexes = function (vertexes) {\n        this.vertexes = vertexes;\n        this.bufferNeeded = true;\n    };\n    Geometry.prototype.getVertexes = function () { return this.vertexes.slice(); };\n    Geometry.prototype.setColors = function (r, g, b, a) {\n        this.colors = [r, g, b, a];\n    };\n    Geometry.prototype.getColors = function () { return this.colors; };\n    Geometry.prototype.setIndexes = function (indexes) {\n        this.indexes = indexes;\n        this.bufferNeeded = true;\n    };\n    Geometry.prototype.getIndexes = function () { return this.indexes; };\n    return Geometry;\n}());\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/Geometry.ts?");

/***/ }),

/***/ "./src/Primitives.ts":
/*!***************************!*\
  !*** ./src/Primitives.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cube: () => (/* binding */ Cube),\n/* harmony export */   Dodecahedron: () => (/* binding */ Dodecahedron),\n/* harmony export */   Icosahedron: () => (/* binding */ Icosahedron),\n/* harmony export */   Octahedron: () => (/* binding */ Octahedron),\n/* harmony export */   Plane: () => (/* binding */ Plane),\n/* harmony export */   Sphere: () => (/* binding */ Sphere),\n/* harmony export */   Tetrahedron: () => (/* binding */ Tetrahedron),\n/* harmony export */   WireCube: () => (/* binding */ WireCube)\n/* harmony export */ });\n/* harmony import */ var _GLWrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLWrapper */ \"./src/GLWrapper.ts\");\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object */ \"./src/object.ts\");\n/* harmony import */ var _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShaderProgramHelper */ \"./src/ShaderProgramHelper.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = _object__WEBPACK_IMPORTED_MODULE_0__.Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (_object__WEBPACK_IMPORTED_MODULE_0__.Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? _object__WEBPACK_IMPORTED_MODULE_0__.Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * A simple plane. Two triangles. Centered around the origin in its object space.\n */\nvar Plane = /** @class */ (function (_super) {\n    __extends(Plane, _super);\n    function Plane(glw) {\n        var _this = _super.call(this, glw) || this;\n        _this.geometry.setIndexes(new Uint16Array([0, 1, 2, 0, 2, 3, 0]));\n        _this.geometry.setVertexes(new Float32Array([\n            -.5, .5, 0,\n            -.5, -.5, 0,\n            .5, -.5, 0,\n            .5, .5, 0,\n        ]));\n        _this.geometry.setColors(1, .7, .75, 1);\n        _this.programShader.attachShaderFromShaderLib(\"v_O2W&color\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.VERTEX);\n        _this.programShader.attachShaderFromShaderLib(\"f_SafeSingleTriWColor\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.FRAGMENT);\n        _this.programShader.linkProgram();\n        return _this;\n    }\n    return Plane;\n}(_object__WEBPACK_IMPORTED_MODULE_0__.Object));\n\n/**\n * A tetrahedron (d4) is a four faced Plutonic Solid.\n * @source - https://en.wikipedia.org/wiki/Tetrahedron#Regular_tetrahedron\n * @source - https://mathworld.wolfram.com/PlatonicSolid.html\n */\nvar Tetrahedron = /** @class */ (function (_super) {\n    __extends(Tetrahedron, _super);\n    function Tetrahedron(glw) {\n        var _this = _super.call(this, glw) || this;\n        _this.geometry.setIndexes(new Uint16Array([\n            //face 1\n            2, 3, 0,\n            2, 0, 1,\n            2, 1, 3,\n            3, 0, 1,\n        ]));\n        _this.geometry.setVertexes(new Float32Array([\n            //0\n            Math.sqrt((8 / 9)), 0, -(1 / 3),\n            //1\n            -Math.sqrt((2 / 9)), Math.sqrt((2 / 3)), -(1 / 3),\n            //2\n            -Math.sqrt((2 / 9)), -Math.sqrt((2 / 3)), -(1 / 3),\n            //3\n            0, 0, 1,\n        ]));\n        _this.geometry.setColors(1, .7, .75, 1);\n        _this.programShader.attachShaderFromShaderLib(\"v_O2W&color\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.VERTEX);\n        _this.programShader.attachShaderFromShaderLib(\"f_SafeSingleTriWColor\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.FRAGMENT);\n        _this.programShader.linkProgram();\n        return _this;\n    }\n    return Tetrahedron;\n}(_object__WEBPACK_IMPORTED_MODULE_0__.Object));\n\n/**\n * A cube containing 6 sides centered about the origin in its object space.\n * @source - https://textbooks.cs.ksu.edu/cis580/13-basic-3d-rendering/04-rendering-a-cube/\n */\nvar Cube = /** @class */ (function (_super) {\n    __extends(Cube, _super);\n    function Cube(glw) {\n        var _this = _super.call(this, glw) || this;\n        _this.geometry.setIndexes(new Uint16Array([\n            0, 1, 2,\n            2, 1, 3,\n            4, 0, 6,\n            6, 0, 2,\n            7, 5, 6,\n            6, 5, 4,\n            3, 1, 7,\n            7, 1, 5,\n            4, 5, 0,\n            0, 5, 1,\n            3, 7, 2,\n            2, 7, 6\n        ]));\n        _this.geometry.setVertexes(new Float32Array([\n            -.5, .5, -.5,\n            .5, .5, -.5,\n            -.5, -.5, -.5,\n            .5, -.5, -.5,\n            -.5, .5, .5,\n            .5, .5, .5,\n            -.5, -.5, .5,\n            .5, -.5, .5,\n        ]));\n        _this.geometry.setColors(1, .7, .75, 1);\n        _this.programShader.attachShaderFromShaderLib(\"v_O2W&color\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.VERTEX);\n        _this.programShader.attachShaderFromShaderLib(\"f_SafeSingleTriWColor\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.FRAGMENT);\n        _this.programShader.linkProgram();\n        return _this;\n    }\n    return Cube;\n}(_object__WEBPACK_IMPORTED_MODULE_0__.Object));\n\n/**\n * A tetrahedron (d8) is a four faced Plutonic Solid.\n * @source - https://en.wikipedia.org/wiki/Octahedron\n * @source - https://mathworld.wolfram.com/PlatonicSolid.html\n */\nvar Octahedron = /** @class */ (function (_super) {\n    __extends(Octahedron, _super);\n    function Octahedron(glw) {\n        var _this = _super.call(this, glw) || this;\n        _this.geometry.setIndexes(new Uint16Array([\n            //Top\n            1, 2, 0,\n            1, 0, 3,\n            1, 3, 5,\n            1, 5, 2,\n            //Bottom\n            4, 0, 2,\n            4, 3, 0,\n            4, 5, 3,\n            4, 2, 5,\n        ]));\n        _this.geometry.setVertexes(new Float32Array([\n            0, 0, 1,\n            0, 1, 0,\n            -1, 0, 0,\n            1, 0, 0,\n            0, -1, 0,\n            0, 0, -1 //5\n        ]));\n        _this.geometry.setColors(1, .7, .75, 1);\n        _this.programShader.attachShaderFromShaderLib(\"v_O2W&color\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.VERTEX);\n        _this.programShader.attachShaderFromShaderLib(\"f_SafeSingleTriWColor\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.FRAGMENT);\n        _this.programShader.linkProgram();\n        return _this;\n    }\n    return Octahedron;\n}(_object__WEBPACK_IMPORTED_MODULE_0__.Object));\n\n/**\n * A tetrahedron (d12) is a four faced Plutonic Solid.\n * @source - https://people.sc.fsu.edu/~jburkardt/data/obj/dodecahedron.obj\n * @source - https://mathworld.wolfram.com/PlatonicSolid.html\n *\n * OBJ Parsing regex\n * /.+\\s* (-*\\d+.*\\d*)\\s* (-*\\d+.*\\d*)\\s* (-*\\d+.*\\d*)/\n */\nvar Dodecahedron = /** @class */ (function (_super) {\n    __extends(Dodecahedron, _super);\n    function Dodecahedron(glw) {\n        var _this = _super.call(this, glw) || this;\n        _this.geometry.setIndexes(new Uint16Array([\n            18, 2, 1,\n            11, 18, 1,\n            14, 11, 1,\n            7, 13, 1,\n            17, 7, 1,\n            2, 17, 1,\n            19, 4, 3,\n            8, 19, 3,\n            15, 8, 3,\n            12, 16, 3,\n            0, 12, 3,\n            4, 0, 3,\n            6, 15, 3,\n            5, 6, 3,\n            16, 5, 3,\n            5, 14, 1,\n            6, 5, 1,\n            13, 6, 1,\n            9, 17, 2,\n            10, 9, 2,\n            18, 10, 2,\n            10, 0, 4,\n            9, 10, 4,\n            19, 9, 4,\n            19, 8, 7,\n            9, 19, 7,\n            17, 9, 7,\n            8, 15, 6,\n            7, 8, 6,\n            13, 7, 6,\n            11, 14, 5,\n            12, 11, 5,\n            16, 12, 5,\n            12, 0, 10,\n            11, 12, 10,\n            18, 11, 10\n        ]));\n        _this.geometry.setVertexes(new Float32Array([\n            -0.57735, -0.57735, 0.57735,\n            0.934172, 0.356822, 0,\n            0.934172, -0.356822, 0,\n            -0.934172, 0.356822, 0,\n            -0.934172, -0.356822, 0,\n            0, 0.934172, 0.356822,\n            0, 0.934172, -0.356822,\n            0.356822, 0, -0.934172,\n            -0.356822, 0, -0.934172,\n            0, -0.934172, -0.356822,\n            0, -0.934172, 0.356822,\n            0.356822, 0, 0.934172,\n            -0.356822, 0, 0.934172,\n            0.57735, 0.57735, -0.57735,\n            0.57735, 0.57735, 0.57735,\n            -0.57735, 0.57735, -0.57735,\n            -0.57735, 0.57735, 0.57735,\n            0.57735, -0.57735, -0.57735,\n            0.57735, -0.57735, 0.57735,\n            -0.57735, -0.57735, -0.57735,\n        ]));\n        _this.geometry.setColors(1, .7, .75, 1);\n        _this.programShader.attachShaderFromShaderLib(\"v_O2W&color\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.VERTEX);\n        _this.programShader.attachShaderFromShaderLib(\"f_SafeSingleTriWColor\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.FRAGMENT);\n        _this.programShader.linkProgram();\n        return _this;\n    }\n    return Dodecahedron;\n}(_object__WEBPACK_IMPORTED_MODULE_0__.Object));\n\nvar Icosahedron = /** @class */ (function (_super) {\n    __extends(Icosahedron, _super);\n    function Icosahedron(glw) {\n        var _this = _super.call(this, glw) || this;\n        _this.geometry.setIndexes(new Uint16Array([\n            1, 2, 6,\n            1, 7, 2,\n            3, 4, 5,\n            4, 3, 8,\n            6, 5, 11,\n            5, 6, 10,\n            9, 10, 2,\n            10, 9, 3,\n            7, 8, 9,\n            8, 7, 0,\n            11, 0, 1,\n            0, 11, 4,\n            6, 2, 10,\n            1, 6, 11,\n            3, 5, 10,\n            5, 4, 11,\n            2, 7, 9,\n            7, 1, 0,\n            3, 9, 8,\n            4, 8, 0\n        ]));\n        _this.geometry.setVertexes(new Float32Array([\n            0, -0.525731, 0.850651,\n            0.850651, 0, 0.525731,\n            0.850651, 0, -0.525731,\n            -0.850651, 0, -0.525731,\n            -0.850651, 0, 0.525731,\n            -0.525731, 0.850651, 0,\n            0.525731, 0.850651, 0,\n            0.525731, -0.850651, 0,\n            -0.525731, -0.850651, 0,\n            0, -0.525731, -0.850651,\n            0, 0.525731, -0.850651,\n            0, 0.525731, 0.850651,\n        ]));\n        _this.geometry.setColors(1, .7, .75, 1);\n        _this.programShader.attachShaderFromShaderLib(\"v_O2W&color\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.VERTEX);\n        _this.programShader.attachShaderFromShaderLib(\"f_SafeSingleTriWColor\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.FRAGMENT);\n        _this.programShader.linkProgram();\n        return _this;\n    }\n    return Icosahedron;\n}(_object__WEBPACK_IMPORTED_MODULE_0__.Object));\n\nvar Sphere = /** @class */ (function (_super) {\n    __extends(Sphere, _super);\n    function Sphere(glw, level) {\n        if (level === void 0) { level = 6; }\n        var _this = _super.call(this, glw) || this;\n        var newGeometry = _this.CreateSphere(glw, level);\n        var newTopology = [];\n        for (var i = 0; i < newGeometry.length; i++) {\n            newTopology.push(i);\n        }\n        _this.geometry.setIndexes(new Uint16Array(newTopology));\n        _this.geometry.setVertexes(new Float32Array(newGeometry));\n        _this.geometry.setColors(1, .7, .75, 1);\n        _this.programShader.attachShaderFromShaderLib(\"v_O2W&color\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.VERTEX);\n        _this.programShader.attachShaderFromShaderLib(\"f_SafeSingleTriWColor\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.FRAGMENT);\n        _this.programShader.linkProgram();\n        return _this;\n    }\n    Sphere.prototype.CreateSphere = function (glw, level) {\n        var baseShape = new Tetrahedron(glw);\n        var topology = baseShape.geometry.getIndexes();\n        var geometry = baseShape.geometry.getVertexes();\n        var newGeometry = [];\n        for (var topologyIndex = 0; topologyIndex < topology.length; topologyIndex += 3) {\n            var vertexA = [\n                geometry[topology[topologyIndex + 0] * 3 + 0],\n                geometry[topology[topologyIndex + 0] * 3 + 1],\n                geometry[topology[topologyIndex + 0] * 3 + 2],\n            ];\n            var vertexB = [\n                geometry[topology[topologyIndex + 1] * 3 + 0],\n                geometry[topology[topologyIndex + 1] * 3 + 1],\n                geometry[topology[topologyIndex + 1] * 3 + 2],\n            ];\n            var vertexC = [\n                geometry[topology[topologyIndex + 2] * 3 + 0],\n                geometry[topology[topologyIndex + 2] * 3 + 1],\n                geometry[topology[topologyIndex + 2] * 3 + 2],\n            ];\n            newGeometry = newGeometry.concat(this.Recursive_CreateSphere(vertexA, vertexB, vertexC, level));\n        }\n        return newGeometry;\n    };\n    Sphere.prototype.Recursive_CreateSphere = function (a, b, c, level) {\n        var _a;\n        if (level <= 0) {\n            return a.concat(b.concat(c));\n        }\n        var d, e, f;\n        _a = this.CalcNewTri(a, b, c), d = _a[0], e = _a[1], f = _a[2];\n        level--;\n        var dfc = this.Recursive_CreateSphere(d, f, c, level);\n        var dae = this.Recursive_CreateSphere(d, a, e, level);\n        var def = this.Recursive_CreateSphere(d, e, f, level);\n        var ebf = this.Recursive_CreateSphere(e, b, f, level);\n        return dfc.concat(dae.concat(def.concat(ebf)));\n    };\n    Sphere.prototype.CalcNewTri = function (a, b, c) {\n        var d = this.vec3Avg([c, a]);\n        var e = this.vec3Avg([a, b]);\n        var f = this.vec3Avg([b, c]);\n        d = this.vec3Norm(d);\n        e = this.vec3Norm(e);\n        f = this.vec3Norm(f);\n        return [d, e, f];\n    };\n    Sphere.prototype.vec3Norm = function (vec3) {\n        var vec3Mag = Math.sqrt(vec3[0] * vec3[0] + vec3[1] * vec3[1] + vec3[2] * vec3[2]);\n        vec3[0] = vec3[0] / vec3Mag;\n        vec3[1] = vec3[1] / vec3Mag;\n        vec3[2] = vec3[2] / vec3Mag;\n        return vec3;\n    };\n    Sphere.prototype.vec3Avg = function (vec3s) {\n        var newVec = [];\n        var _loop_1 = function (i) {\n            var total = 0;\n            vec3s.forEach(function (vec3) { total += vec3[i]; });\n            newVec.push(total / vec3s.length);\n        };\n        for (var i = 0; i < 3; i++) {\n            _loop_1(i);\n        }\n        return newVec;\n    };\n    return Sphere;\n}(_object__WEBPACK_IMPORTED_MODULE_0__.Object));\n\n/**\n * The wireframe of a cube centered around the origin in object space.\n */\nvar WireCube = /** @class */ (function (_super) {\n    __extends(WireCube, _super);\n    function WireCube(glw) {\n        var _this = _super.call(this, glw) || this;\n        _this.drawMode = _GLWrapper__WEBPACK_IMPORTED_MODULE_1__.GL_Wrapper.drawModes.LINES;\n        _this.geometry.setIndexes(new Uint16Array([\n            0, 1, 2, 0,\n            2, 1, 3, 2,\n            4, 0, 6, 4,\n            6, 0, 2, 6,\n            7, 5, 6, 7,\n            6, 5, 4, 6,\n            3, 1, 7, 3,\n            7, 1, 5, 7,\n            4, 5, 0, 4,\n            0, 5, 1, 0,\n            3, 7, 2, 3,\n            2, 7, 6, 2,\n        ]));\n        _this.geometry.setVertexes(new Float32Array([\n            -.5, .5, -.5,\n            .5, .5, -.5,\n            -.5, -.5, -.5,\n            .5, -.5, -.5,\n            -.5, .5, .5,\n            .5, .5, .5,\n            -.5, -.5, .5,\n            .5, -.5, .5,\n        ]));\n        _this.geometry.setColors(1, .7, .75, 1);\n        _this.programShader.attachShaderFromShaderLib(\"v_O2W&color\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.VERTEX);\n        _this.programShader.attachShaderFromShaderLib(\"f_SafeSingleTriWColor\", _ShaderProgramHelper__WEBPACK_IMPORTED_MODULE_2__.ShaderProgramHelper.shaderTypes.FRAGMENT);\n        return _this;\n    }\n    return WireCube;\n}(_object__WEBPACK_IMPORTED_MODULE_0__.Object));\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/Primitives.ts?");

/***/ }),

/***/ "./src/Scene.ts":
/*!**********************!*\
  !*** ./src/Scene.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scene: () => (/* binding */ Scene)\n/* harmony export */ });\nvar Scene = /** @class */ (function () {\n    function Scene(camera) {\n        var _this = this;\n        this.objects = {};\n        this.actions = {};\n        this.drawInterval = setInterval(function () {\n            var stamp = Date.now();\n            Object.entries(_this.objects).forEach(function (_a) {\n                var key = _a[0], val = _a[1];\n                val.draw(_this.camera, _this.isWire);\n            });\n            console.log(\"Frame took: \".concat((Date.now() - stamp) / 1000));\n        }, 1000 / 30);\n        this.camera = camera;\n        this.isWire = false;\n    }\n    Scene.prototype.ToggleWire = function () { this.isWire = !this.isWire; };\n    return Scene;\n}());\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/Scene.ts?");

/***/ }),

/***/ "./src/ShaderLibrary.ts":
/*!******************************!*\
  !*** ./src/ShaderLibrary.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHADER_LIB: () => (/* binding */ SHADER_LIB)\n/* harmony export */ });\nvar SHADER_LIB = new Map([\n    [\"v_SafeSingleTri\", \"attribute vec3 vertex_position;\\nattribute vec3 vertex_color;\\nvarying vec3 vColor;\\nvoid main() {\\ngl_Position = vec4(vertex_position, 1.0);\\nvColor = vertex_color;\\n}\\n\"],\n    [\"f_SafeSingleTriWColor\", \"\\n        precision highp float;\\n        varying vec4 vColor;\\n        void main() {\\n            gl_FragColor = vColor;\\n        }\\n    \"],\n    [\"v_O2W&color\", \"\\n        attribute vec3 vertex_position;\\n        \\n        uniform vec4 color;\\n        uniform mat4 objectToWorld;\\n        uniform mat4 worldToCamera;\\n        uniform mat4 cameraToProjection;\\n\\n        varying vec4 vColor;\\n\\n        void main() {\\n            vec4 vertex =  cameraToProjection * worldToCamera * objectToWorld * vec4(vertex_position, 1);\\n            gl_Position = vertex;\\n            vColor = color;\\n        }\\n    \"]\n]);\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/ShaderLibrary.ts?");

/***/ }),

/***/ "./src/ShaderProgramHelper.ts":
/*!************************************!*\
  !*** ./src/ShaderProgramHelper.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderProgramHelper: () => (/* binding */ ShaderProgramHelper)\n/* harmony export */ });\n/* harmony import */ var _ShaderLibrary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderLibrary */ \"./src/ShaderLibrary.ts\");\n\nvar ShaderProgramHelper = /** @class */ (function () {\n    function ShaderProgramHelper(context) {\n        this.context = context;\n        this.program = context.createProgram();\n    }\n    /**\n     * attachShaderFromShaderLib\n     * Loads a shader from shader library.\n     * @param {string} shaderSourceName - The name of the shader in the library.\n     * @param {ShaderProgramHelper.shaderTypes} shadertype -  The type of shader the code is for.\n     */\n    ShaderProgramHelper.prototype.attachShaderFromShaderLib = function (shaderSourceName, shadertype) {\n        if (!_ShaderLibrary__WEBPACK_IMPORTED_MODULE_0__.SHADER_LIB.has(shaderSourceName)) {\n            throw \"Cannot find shader: \".concat(shaderSourceName, \" in shader library!\");\n        }\n        ;\n        this.attachShaderFromString(_ShaderLibrary__WEBPACK_IMPORTED_MODULE_0__.SHADER_LIB.get(shaderSourceName), shadertype);\n    };\n    /**\n     * attachShaderFromString\n     * Loads a shader from a string.\n     * @param {string} shaderSourceStr - The string of shader source code.\n     * @param {ShaderProgramHelper.shaderTypes} shadertype -  The type of shader the code is for.\n     */\n    ShaderProgramHelper.prototype.attachShaderFromString = function (shaderSourceStr, shadertype) {\n        //Map our enums to OpenGL enums.\n        var glShaderTypeID;\n        switch (shadertype) {\n            case ShaderProgramHelper.shaderTypes.VERTEX: {\n                glShaderTypeID = this.context.VERTEX_SHADER;\n                break;\n            }\n            case ShaderProgramHelper.shaderTypes.FRAGMENT: {\n                glShaderTypeID = this.context.FRAGMENT_SHADER;\n                break;\n            }\n            default: {\n                throw \"Cant implement shadertype: \".concat(shadertype, \" in func attachShaderFromString!\");\n            }\n        }\n        //Make the shader and compile it\n        var shaderObj = this.context.createShader(glShaderTypeID);\n        this.context.shaderSource(shaderObj, shaderSourceStr);\n        this.context.compileShader(shaderObj);\n        if (!this.context.getShaderParameter(shaderObj, this.context.COMPILE_STATUS)) {\n            var info = this.context.getShaderInfoLog(shaderObj);\n            throw \"Could not compile shader \".concat(shadertype, \". \\n\\n\").concat(info);\n        }\n        //Attach the shader to the program\n        this.context.attachShader(this.program, shaderObj);\n    };\n    /**\n     * useProgram\n     * Links, compiles program. Then sets this program to be used for the context it was made with.\n     */\n    ShaderProgramHelper.prototype.useProgram = function () {\n        this.context.useProgram(this.program);\n    };\n    ShaderProgramHelper.prototype.linkProgram = function () {\n        this.context.linkProgram(this.program);\n        if (!this.context.getProgramParameter(this.program, this.context.LINK_STATUS)) {\n            var info = this.context.getProgramInfoLog(this.program);\n            throw \"Could not compile WebGL program. \\n\\n\".concat(info);\n        }\n    };\n    /**\n     * getAttributeLocation\n     * Get the location of an attribute in the program by its name.\n     * This will compile link and set the program to be used!\n     * @param {string} name - The text name attribute to find the location of\n     * @returns {number}\n     */\n    ShaderProgramHelper.prototype.getAttributeLocation = function (name) {\n        //TODO::Make it to where we don't have to link and select the program every \n        //time we want to look up and attribute!\n        return this.context.getAttribLocation(this.program, name);\n    };\n    /**\n * getAttributeLocation\n * Get the location of a uniform in the program by its name.\n * This will compile link and set the program to be used!\n * @param {string} name - The text name uniform to find the location of\n * @returns {number}\n */\n    ShaderProgramHelper.prototype.getUniformLocation = function (name) {\n        //TODO::Make it to where we don't have to link and select the program every \n        //time we want to look up and uniform!\n        //this.useProgram();\n        return this.context.getUniformLocation(this.program, name);\n    };\n    return ShaderProgramHelper;\n}());\n\n(function (ShaderProgramHelper) {\n    var shaderTypes;\n    (function (shaderTypes) {\n        shaderTypes[shaderTypes[\"VERTEX\"] = 0] = \"VERTEX\";\n        shaderTypes[shaderTypes[\"FRAGMENT\"] = 1] = \"FRAGMENT\";\n    })(shaderTypes = ShaderProgramHelper.shaderTypes || (ShaderProgramHelper.shaderTypes = {}));\n})(ShaderProgramHelper || (ShaderProgramHelper = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/ShaderProgramHelper.ts?");

/***/ }),

/***/ "./src/Transform.ts":
/*!**************************!*\
  !*** ./src/Transform.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: () => (/* binding */ Transform)\n/* harmony export */ });\nvar Transform = /** @class */ (function () {\n    function Transform() {\n        this.TranslationMatrix = Transform.getIdentity();\n        this.ScalingMatrix = Transform.getIdentity();\n        this.XRotationMatrix = Transform.getIdentity();\n        this.YRotationMatrix = Transform.getIdentity();\n        this.ZRotationMatrix = Transform.getIdentity();\n        this.rotations = [0, 0, 0];\n    }\n    Transform.getIdentity = function () {\n        return [[1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],];\n    };\n    /**\n     * setTranslation\n     * Loads this transform with a translation int the x, y, and z, direction\n     * @param {number} x - The amount of units to translate in the x direction\n     * @param {number} y - The amount of units to translate in the y direction\n     * @param {number} z - The amount of units to translate in the z direction\n     */\n    Transform.prototype.setTranslation = function (x, y, z) {\n        var translation = Transform.getIdentity();\n        translation[0][3] = x;\n        translation[1][3] = y;\n        translation[2][3] = z;\n        this.TranslationMatrix = translation;\n    };\n    /**\n     * getTranslation\n     * Gets the currently set translation int the x, y, and z, direction\n     * @returns {number[]} - The loaded translations [x, y, z]\n     */\n    Transform.prototype.getTranslation = function () {\n        return [this.TranslationMatrix[0][3], this.TranslationMatrix[1][3], this.TranslationMatrix[2][3]];\n    };\n    /**\n     * setScaling\n     * Loads this transform with a scaling in the x, y, and z, direction\n     * @param {number} x - The amount of to scale in the x direction\n     * @param {number} y - The amount of to scale in the y direction\n     * @param {number} z - The amount of to scale in the z direction\n     */\n    Transform.prototype.setScaling = function (x, y, z) {\n        var scaling = Transform.getIdentity();\n        scaling[0][0] = x;\n        scaling[1][1] = y;\n        scaling[2][2] = z;\n        this.ScalingMatrix = scaling;\n    };\n    /**\n     * getScaling\n     * Gets the currently set scaling in the x, y, and z, direction\n     * @returns {number[]} - The loaded scaling [x, y, z]\n     */\n    Transform.prototype.getScaling = function () {\n        return [this.ScalingMatrix[1][1], this.ScalingMatrix[2][2], this.ScalingMatrix[3][3]];\n    };\n    /**\n     * setRotation\n     * Loads this transform with a rotation in the x, y, and z, axis.\n     * @NOTE - Units in degrees and rotations are always CCW\n     * @param {number} x - The amount of DEGREES to rotate CCW in the x direction\n     * @param {number} y - The amount of DEGREES to rotate CCW in the y direction\n     * @param {number} z - The amount of DEGREES to rotate CCW in the z direction\n     */\n    Transform.prototype.setRotation = function (x, y, z) {\n        this.XRotationMatrix = this.createXRotationMatrix(x);\n        this.YRotationMatrix = this.createYRotationMatrix(y);\n        this.ZRotationMatrix = this.createZRotationMatrix(z);\n        this.rotations = [x, y, z];\n    };\n    /**\n     * getRotation\n     * Gets the currently set rotation in the x, y, and z, axis\n     * @returns {number[]} - The loaded rotation [x, y, z]\n     */\n    Transform.prototype.getRotation = function () {\n        return this.rotations;\n    };\n    /**\n     * computeTransformMatrix\n     * Fully computes the full transform uniform\n     * @returns {number[][]} - The matrix in column major order\n     * @source - https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript\n     */\n    Transform.prototype.computeTransformMatrix = function () {\n        var matrix;\n        matrix = Transform.multiply4x4Matrixes(this.TranslationMatrix, this.XRotationMatrix); //T_RX\n        matrix = Transform.multiply4x4Matrixes(matrix, this.YRotationMatrix); //T_RX_RY\n        matrix = Transform.multiply4x4Matrixes(matrix, this.ZRotationMatrix); //T_RX_RY_RZ\n        matrix = Transform.multiply4x4Matrixes(matrix, this.ScalingMatrix); //T_RX_RY_RZ_S\n        var transform = new Float32Array(16);\n        for (var r = 0; r < 4; r++) {\n            for (var c = 0; c < 4; c++) {\n                transform[r + 4 * c] = matrix[r][c];\n            }\n        }\n        return transform;\n    };\n    /**\n     * multiply4x4Matrixes\n     * Multiplies two 4x4 matrixes\n     * @param {number[][]}\n     * @param {number[][]}\n     * @returns {number[][]} - The matrix in column major order\n     * @source - https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript\n     */\n    Transform.multiply4x4Matrixes = function (matrixA, matrixB) {\n        var transformMatrix = this.getIdentity();\n        for (var r = 0; r < 4; r++) {\n            for (var c = 0; c < 4; c++) {\n                transformMatrix[r][c] = 0;\n                for (var i = 0; i < 4; i++) {\n                    transformMatrix[r][c] += matrixA[r][i] * matrixB[i][c];\n                }\n            }\n        }\n        //console.log (transformMatrix);\n        return transformMatrix;\n    };\n    /**\n     * createXRotationMatrix\n     * Creates a rotation matrix for the x axis given degrees to rotate CCW\n     * @param {number} degrees - The degrees to rotate\n     * @returns {number[][]} - The rotation matrix in column major order\n     */\n    Transform.prototype.createXRotationMatrix = function (degrees) {\n        var radians = degrees * (Transform.r2d);\n        var radCos = Math.cos(radians);\n        var radSin = Math.sin(radians);\n        /* Rotation matrix, its returned as one line as it has to be in column major order >:(\n            1,      0,     0, 0\n            0,  cos γ, sin γ, 0\n            0  -sin γ  cos γ, 0\n            0       0      0, 1\n        */\n        return [[1, 0, 0, 0],\n            [0, radCos, radSin, 0],\n            [0, -radSin, radCos, 0],\n            [0, 0, 0, 1]];\n    };\n    /**\n     * createYRotationMatrix\n     * Creates a rotation matrix for the y axis given degrees to rotate CCW\n     * @param {number} degrees - The degrees to rotate\n     * @returns {number[][]} - The rotation matrix in column major order\n     */\n    Transform.prototype.createYRotationMatrix = function (degrees) {\n        var radians = degrees * (Transform.r2d);\n        var radCos = Math.cos(radians);\n        var radSin = Math.sin(radians);\n        /* Rotation matrix, its returned as one line as it has to be in column major order >:(\n            cos γ, -sin γ, 0, 0\n            sin γ,  cos γ, 0, 0\n            0       0      1, 0\n            0       0      0, 1\n        */\n        return [[radCos, 0, radSin, 0],\n            [0, 1, 0, 0],\n            [-radSin, 0, radCos, 0],\n            [0, 0, 0, 1]];\n    };\n    /**\n     * createZRotationMatrix\n     * Creates a rotation matrix for the z axis given degrees to rotate CCW\n     * @param {number} degrees - The degrees to rotate\n     * @returns {number[][]} - The rotation matrix in column major order\n     */\n    Transform.prototype.createZRotationMatrix = function (degrees) {\n        var radians = degrees * (Transform.r2d);\n        var radCos = Math.cos(radians);\n        var radSin = Math.sin(radians);\n        /* Rotation matrix, its returned as one line as it has to be in column major order >:(\n            cos γ, -sin γ, 0, 0\n            sin γ,  cos γ, 0, 0\n            0       0      1, 0\n            0       0      0, 1\n        */\n        return [[radCos, radSin, 0, 0],\n            [-radSin, radCos, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]];\n    };\n    Transform.r2d = Math.PI / 180;\n    return Transform;\n}());\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/Transform.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera */ \"./src/Camera.ts\");\n/* harmony import */ var _GLWrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLWrapper */ \"./src/GLWrapper.ts\");\n/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Scene */ \"./src/Scene.ts\");\n/* harmony import */ var _Primitives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Primitives */ \"./src/Primitives.ts\");\n\n\n\n\nvar width = 800;\nvar height = 800;\nvar canvas = document.getElementById('screen');\ncanvas.width = width;\ncanvas.height = height;\nvar glw = new _GLWrapper__WEBPACK_IMPORTED_MODULE_1__.GL_Wrapper(canvas);\nvar cameraAngels = [];\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\ncameraAngels[0].setCameraToProjectionMatrix(90, width / height, .1, 2000);\ncameraAngels[0].transform.setTranslation(-50, -25, 0);\ncameraAngels[0].transform.setRotation(-90, 0, 0);\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\ncameraAngels[1].setCameraToProjectionMatrix(90, width / height, .1, 2000);\ncameraAngels[1].transform.setTranslation(-25, -25, 0);\ncameraAngels[1].transform.setRotation(-90, 0, 0);\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\ncameraAngels[2].setCameraToProjectionMatrix(90, width / height, .1, 2000);\ncameraAngels[2].transform.setTranslation(0, -25, 0);\ncameraAngels[2].transform.setRotation(-90, 0, 0);\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\ncameraAngels[3].setCameraToProjectionMatrix(90, width / height, .1, 2000);\ncameraAngels[3].transform.setTranslation(25, -25, 0);\ncameraAngels[3].transform.setRotation(-90, 0, 0);\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\ncameraAngels[4].setCameraToProjectionMatrix(90, width / height, .1, 2000);\ncameraAngels[4].transform.setTranslation(50, -25, 0);\ncameraAngels[4].transform.setRotation(-90, 0, 0);\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\ncameraAngels[5].setCameraToProjectionMatrix(90, width / height, .1, 2000);\ncameraAngels[5].transform.setTranslation(75, -25, 0);\ncameraAngels[5].transform.setRotation(-90, 0, 0);\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\ncameraAngels[6].setCameraToProjectionMatrix(60, width / height, .1, 2000);\ncameraAngels[6].transform.setTranslation(0, 10, 0);\ncameraAngels[6].transform.setRotation(30, 0, 0);\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\ncameraAngels[7].setCameraToProjectionMatrix(60, width / height, .1, 2000);\ncameraAngels[7].transform.setTranslation(0, 5, -5);\ncameraAngels[7].transform.setRotation(0, 0, 0);\ncameraAngels.push(new _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera());\nvar scene1 = new _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene(cameraAngels[6]);\nscene1.objects['Ground'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Cube(glw);\nscene1.objects['Ground'].transform.setTranslation(0, -1.5, 0);\nscene1.objects['Ground'].transform.setScaling(1000, .2, 1000);\nscene1.objects['Ground'].geometry.setColors(.85, .75, .55, 1);\nscene1.objects['Sky'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Cube(glw);\nscene1.objects['Sky'].transform.setTranslation(0, 0, -200);\nscene1.objects['Sky'].transform.setScaling(1000, 1000, .2);\nscene1.objects['Sky'].geometry.setColors(.4, .8, .9, 1);\nscene1.objects['Tetrahedron'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Tetrahedron(glw);\nscene1.objects['Tetrahedron'].transform.setTranslation(-6, 0, -10);\nscene1.objects['Cube'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Cube(glw);\nscene1.objects['Cube'].transform.setTranslation(-3, 0, -10);\nscene1.objects['Octahedron'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Octahedron(glw);\nscene1.objects['Octahedron'].transform.setTranslation(0, 0, -10);\nscene1.objects['Dodecahedron'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Dodecahedron(glw);\nscene1.objects['Dodecahedron'].transform.setTranslation(3, 0, -10);\nscene1.objects['Icosahedron'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Icosahedron(glw);\nscene1.objects['Icosahedron'].transform.setTranslation(6, 0, -10);\nvar sphereLOD = 6;\nscene1.objects['Sphere'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Sphere(glw, sphereLOD);\nscene1.objects['Sphere'].transform.setTranslation(-6, 5, -10);\nscene1.objects['Sphere'].transform.setScaling(.2, .2, .2);\nscene1.objects['Sphere1'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Sphere(glw, sphereLOD);\nscene1.objects['Sphere1'].transform.setTranslation(-3, 5, -10);\nscene1.objects['Sphere1'].transform.setScaling(.6, .6, .6);\nscene1.objects['Sphere2'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Sphere(glw, sphereLOD);\nscene1.objects['Sphere2'].transform.setTranslation(0, 5, -10);\nscene1.objects['Sphere2'].transform.setScaling(.8, .8, .8);\nscene1.objects['Sphere3'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Sphere(glw, sphereLOD);\nscene1.objects['Sphere3'].transform.setTranslation(3, 5, -10);\nscene1.objects['Sphere3'].transform.setScaling(1, 1, 1);\nscene1.objects['Sphere4'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Sphere(glw, sphereLOD);\nscene1.objects['Sphere4'].transform.setTranslation(6, 5, -10);\nscene1.objects['Sphere4'].transform.setScaling(1.2, 1.2, 1.2);\nvar cameraPOS;\nscene1.objects['Show_Tetrahedron'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Tetrahedron(glw);\ncameraPOS = cameraAngels[0].transform.getTranslation();\nscene1.objects['Show_Tetrahedron'].transform.setTranslation(cameraPOS[0], cameraPOS[1] + 26, cameraPOS[2] - 25);\nscene1.objects['Show_Cube'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Cube(glw);\ncameraPOS = cameraAngels[1].transform.getTranslation();\nscene1.objects['Show_Cube'].transform.setTranslation(cameraPOS[0], cameraPOS[1] + 26, cameraPOS[2] - 25);\nscene1.objects['Show_Octahedron'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Octahedron(glw);\ncameraPOS = cameraAngels[2].transform.getTranslation();\nscene1.objects['Show_Octahedron'].transform.setTranslation(cameraPOS[0], cameraPOS[1] + 26, cameraPOS[2] - 25);\nscene1.objects['Show_Dodecahedron'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Dodecahedron(glw);\ncameraPOS = cameraAngels[3].transform.getTranslation();\nscene1.objects['Show_Dodecahedron'].transform.setTranslation(cameraPOS[0], cameraPOS[1] + 26, cameraPOS[2] - 25);\nscene1.objects['Show_Icosahedron'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Icosahedron(glw);\ncameraPOS = cameraAngels[4].transform.getTranslation();\nscene1.objects['Show_Icosahedron'].transform.setTranslation(cameraPOS[0], cameraPOS[1] + 26, cameraPOS[2] - 25);\nscene1.objects['Show_Sp'] = new _Primitives__WEBPACK_IMPORTED_MODULE_3__.Sphere(glw, sphereLOD);\ncameraPOS = cameraAngels[5].transform.getTranslation();\nscene1.objects['Show_Sp'].transform.setTranslation(cameraPOS[0], cameraPOS[1] + 26, cameraPOS[2] - 25);\nvar rotation = 0;\nscene1.actions['Standard rotations'] = setInterval(function () {\n    Object.entries(scene1.objects).forEach(function (_a) {\n        var key = _a[0], value = _a[1];\n        if (key != 'Sky' && key != 'Ground') {\n            value.transform.setRotation(30, rotation, rotation);\n        }\n    });\n    rotation = (rotation + 3) % 360;\n}, 1000 / 30);\nvar sphereHeight = 5;\nvar delta = .05;\nscene1.actions['Sphere Dance'] = setInterval(function () {\n    Object.entries(scene1.objects).forEach(function (_a) {\n        var key = _a[0], value = _a[1];\n        if (key.includes('Sphere')) {\n            sphereHeight += delta;\n            var translation = value.transform.getTranslation();\n            value.transform.setTranslation(translation[0], sphereHeight, translation[2]);\n        }\n    });\n    delta *= (sphereHeight > 7 || sphereHeight < 5 ? -1 : 1);\n}, 1000 / 30);\nvar body = document.getElementById('body');\nbody === null || body === void 0 ? void 0 : body.addEventListener('keydown', function (evt) {\n    if (evt.key == 'w') {\n        scene1.ToggleWire();\n    }\n    if (evt.key == '1') {\n        scene1.camera = cameraAngels[0];\n    }\n    if (evt.key == '2') {\n        scene1.camera = cameraAngels[1];\n    }\n    if (evt.key == '3') {\n        scene1.camera = cameraAngels[2];\n    }\n    if (evt.key == '4') {\n        scene1.camera = cameraAngels[3];\n    }\n    if (evt.key == '5') {\n        scene1.camera = cameraAngels[4];\n    }\n    if (evt.key == '6') {\n        scene1.camera = cameraAngels[5];\n    }\n    if (evt.key == '7') {\n        scene1.camera = cameraAngels[6];\n    }\n    if (evt.key == '8') {\n        scene1.camera = cameraAngels[7];\n    }\n    if (evt.key == '9') {\n        scene1.camera = cameraAngels[8];\n    }\n});\n\n\n//# sourceURL=webpack://my-webpack-project/./src/index.ts?");

/***/ }),

/***/ "./src/object.ts":
/*!***********************!*\
  !*** ./src/object.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Object: () => (/* binding */ Object)\n/* harmony export */ });\n/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transform */ \"./src/Transform.ts\");\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Geometry */ \"./src/Geometry.ts\");\n/* harmony import */ var _GLWrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GLWrapper */ \"./src/GLWrapper.ts\");\n\n\n\nvar Object = /** @class */ (function () {\n    function Object(glw) {\n        this.transform = new _Transform__WEBPACK_IMPORTED_MODULE_0__.Transform();\n        this.geometry = new _Geometry__WEBPACK_IMPORTED_MODULE_1__.Geometry();\n        this.programShader = glw.makeSeededProgramWrapper();\n        this.GLW = glw;\n    }\n    /**\n     * draw()\n     * Draws the object to the loaded context.\n     */\n    Object.prototype.draw = function (camera, isWire) {\n        if (isWire === void 0) { isWire = false; }\n        var stamp = Date.now();\n        if (this.geometry.bufferNeeded) {\n            this.buffer();\n            this.geometry.bufferNeeded = false;\n        }\n        this.GLW.attachProgramWrapper(this.programShader);\n        this.GLW.bindAttributeNameToBuffer(this.verticesBuffer, \"vertex_position\", 3, false, 0, 0);\n        this.GLW.bindMatrixUniform(this.transform.computeTransformMatrix(), 4, \"objectToWorld\");\n        this.GLW.bindMatrixUniform(camera.getWorldToCameraMatrix(), 4, \"worldToCamera\");\n        this.GLW.bindMatrixUniform(camera.getCameraToProjectionMatrix(), 4, \"cameraToProjection\");\n        this.GLW.bindVectorUniform(this.geometry.getColors(), 'color');\n        this.GLW.draw(this.indicesBuffer, this.geometry.getIndexes().length, isWire ? _GLWrapper__WEBPACK_IMPORTED_MODULE_2__.GL_Wrapper.drawModes.LINES : _GLWrapper__WEBPACK_IMPORTED_MODULE_2__.GL_Wrapper.drawModes.TRIANGLES);\n        console.log(\"Draw obj: \".concat((Date.now() - stamp) / 1000));\n    };\n    Object.prototype.buffer = function () {\n        console.log('Buffer needed');\n        this.GLW.deleteBuffer(this.verticesBuffer);\n        this.GLW.deleteBuffer(this.colorBuffer);\n        this.GLW.deleteBuffer(this.indicesBuffer);\n        this.verticesBuffer = this.GLW.buildAndPushArrayBuffer(this.geometry.getVertexes());\n        this.indicesBuffer = this.GLW.buildAndPushElementArrayBuffer(this.geometry.getIndexes());\n    };\n    return Object;\n}());\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/object.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;